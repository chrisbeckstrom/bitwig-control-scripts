// load the bitwig API
loadAPI(1);

// DEFINE/set our controller properties
// used autogenerated UUID
// https://www.famkruithof.net/uuid/uuidgen
// tutorial: https://www.keithmcmillen.com/blog/controller-scripting-in-bitwig-studio-part-1/
host.defineController("beckstrom", "xsession", "1.0", "4e9916c0-7a1f-11e7-9598-0800200c9a66");

host.defineMidiPorts(1, 0);

// define the range of our CCs
var CC_RANGE_HI = 127;
var CC_RANGE_LO = 1;

var DEVICE_START_CC = 1;
var DEVICE_END_CC = 127;


// ------------------------ INIT ------------------------- //
function init()
{
   // cb tries to set up remote controls
   // copied from generic keyboard with 8 knobs script
   cursorTrack = host.createCursorTrack(3, 0);
   cursorDevice = cursorTrack.createCursorDevice();
   remoteControls = cursorDevice.createCursorRemoteControlsPage(8);

   // transport
   transport = host.createTransport();

   // set midi callbacks / port	
   host.getMidiInPort(0).setMidiCallback(onMidiPort1);
   
   // ?? something about sysex
   host.getMidiInPort(0).setSysexCallback(onSysex);

   // sends notes to bitwig, with no input filters
   noteIn = host.getMidiInPort(0).createNoteInput("Notes");

   // add this so bitwig will grab notes
   noteIn.setShouldConsumeEvents(false);

   // tries to set 8 specific cc's as remote controls
   	i = 25;
   	var p = remoteControls.getParameter(i).getAmount();
	p.setIndication(true);
	p.setLabel("P" + (i + 1));

   // make the rest of the cc's freely mapable	
   // creates an array of user controls with the proper amount of CC#s
   userControls = host.createUserControlsSection(CC_RANGE_HI - CC_RANGE_LO + 1);
   
   // iterate over the userControls and assign the CC# to each control
   for ( var i = CC_RANGE_LO; i<=CC_RANGE_HI; i ++)
   {
	   userControls.getControl(i - CC_RANGE_LO).setLabel("CC" + i);
   }


};




}



function onMidiPort1(status, data1, data2)
{
	// this is where you could do stuff with MIDI data
	// with nothing in here, it just passes the notes
	//
	// bitwig deals with MIDI as a status byte and two data bytes
	
	// checks if the MIDI data is a CC
	if (isChannelControllers(status))
	{
		// if it is, check if the CC is within our range
		if (data1 >= CC_RANGE_LO && data1 <= CC_RANGE_HI)
		{
			// if it is, get the index of the CC in our userControls
			// and set the value of the control to the value of our CC
			var index = data1 - CC_RANGE_LO;
			userControls.getControl(index).set(data2, 128);
		}
	}else{ 
		// if the data isn't a controller, it's probably a note
		// hardcode a specific midi note to control transport
		if (data1 == 60 && data2 > 0){	// data2 is velocity
			transport.play();
		}
	}

}

function exit()
{
	// this is a notification when you disconnect the device
	// that connected to this script. not necessary but good to have (?)
	println("exit.");
}

function onMidi(status, data1, data2)
{
}

function onSysex(data)
{
}
